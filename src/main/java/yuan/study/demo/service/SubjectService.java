package yuan.study.demo.service;


public interface SubjectService {

    /**
     * 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
     *
     * 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
     *
     * 你可以按任意顺序返回答案。
     *
     *
     *
     * 示例 1：
     *
     *
     * 输入：nums = [2,7,11,15], target = 9
     * 输出：[0,1]
     * 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
     *
     *
     * 示例 2：
     *
     *
     * 输入：nums = [3,2,4], target = 6
     * 输出：[1,2]
     *
     *
     * 示例 3：
     *
     *
     * 输入：nums = [3,3], target = 6
     * 输出：[0,1]
     *
     *
     *
     *
     * 提示：
     *
     *
     * 2 <= nums.length <= 104
     * -109 <= nums[i] <= 109
     * -109 <= target <= 109
     * 只会存在一个有效答案
     *
     *
     * 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？
     * Related Topics 数组 哈希表
     * 👍 11871 👎 0
     */
    void subjectTest();

    /**
     * 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
     *
     *  请你将两个数相加，并以相同形式返回一个表示和的链表。
     *
     *  你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
     *
     *
     *
     *  示例 1：
     *
     *
     * 输入：l1 = [2,4,3], l2 = [5,6,4]
     * 输出：[7,0,8]
     * 解释：342 + 465 = 807.
     *
     *
     *  示例 2：
     *
     *
     * 输入：l1 = [0], l2 = [0]
     * 输出：[0]
     *
     *
     *  示例 3：
     *
     *
     * 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
     * 输出：[8,9,9,9,0,0,0,1]
     *
     *
     *
     *
     *  提示：
     *
     *
     *  每个链表中的节点数在范围 [1, 100] 内
     *  0 <= Node.val <= 9
     *  题目数据保证列表表示的数字不含前导零
     *
     *  Related Topics 递归 链表 数学
     *  👍 6624 👎 0
     */
    void addTwoNumbers();

    /**
     * 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
     *
     *
     *
     *  示例 1:
     *
     *
     * 输入: s = "abcabcbb"
     * 输出: 3
     * 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
     *
     *
     *  示例 2:
     *
     *
     * 输入: s = "bbbbb"
     * 输出: 1
     * 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
     *
     *
     *  示例 3:
     *
     *
     * 输入: s = "pwwkew"
     * 输出: 3
     * 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     *      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
     *
     *
     *  示例 4:
     *
     *
     * 输入: s = ""
     * 输出: 0
     *
     *
     *
     *
     *  提示：
     *
     *
     *  0 <= s.length <= 5 * 104
     *  s 由英文字母、数字、符号和空格组成
     *
     *  Related Topics 哈希表 字符串 滑动窗口
     *  👍 5986 👎 0
     */
    void longestSubstringWithoutRepeatedCharacters();

    /**
     * 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
     *
     *
     *
     *  示例 1：
     *
     *
     * 输入：nums1 = [1,3], nums2 = [2]
     * 输出：2.00000
     * 解释：合并数组 = [1,2,3] ，中位数 2
     *
     *
     *  示例 2：
     *
     *
     * 输入：nums1 = [1,2], nums2 = [3,4]
     * 输出：2.50000
     * 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
     *
     *
     *  示例 3：
     *
     *
     * 输入：nums1 = [0,0], nums2 = [0,0]
     * 输出：0.00000
     *
     *
     *  示例 4：
     *
     *
     * 输入：nums1 = [], nums2 = [1]
     * 输出：1.00000
     *
     *
     *  示例 5：
     *
     *
     * 输入：nums1 = [2], nums2 = []
     * 输出：2.00000
     *
     *
     *
     *
     *  提示：
     *
     *
     *  nums1.length == m
     *  nums2.length == n
     *  0 <= m <= 1000
     *  0 <= n <= 1000
     *  1 <= m + n <= 2000
     *  -106 <= nums1[i], nums2[i] <= 106
     *
     *
     *
     *
     *  进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？
     *  Related Topics 数组 二分查找 分治
     *  👍 4427 👎 0
     */
    void queryPositiveArrayMedian();

    /**
     * //给你一个字符串 s，找到 s 中最长的回文子串。
     * //
     * //
     * //
     *  示例 1：
     *
     *
     * 输入：s = "babad"
     * 输出："bab"
     * 解释："aba" 同样是符合题意的答案。
     *
     *
     *  示例 2：
     *
     *
     * 输入：s = "cbbd"
     * 输出："bb"
     *
     *
     *  示例 3：
     *
     *
     * 输入：s = "a"
     * 输出："a"
     *
     *
     *  示例 4：
     *
     *
     * 输入：s = "ac"
     * 输出："a"
     *
     *
     *
     *
     *  提示：
     *
     *
     *  1 <= s.length <= 1000
     *  s 仅由数字和英文字母（大写和/或小写）组成
     *
     *  Related Topics 字符串 动态规划
     *  👍 4065 👎 0
     */
    void getTheLongestPalindromeString();

    /**
     * //将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。
     * //
     * // 比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：
     * //
     * //
     * //P   A   H   N
     * //A P L S I I G
     * //Y   I   R
     * //
     * // 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。
     * //
     * // 请你实现这个将字符串进行指定行数变换的函数：
     * //
     * //
     * //string convert(string s, int numRows);
     * //
     * //
     * //
     * // 示例 1：
     * //
     * //
     * //输入：s = "PAYPALISHIRING", numRows = 3
     * //输出："PAHNAPLSIIGYIR"
     * //
     * //示例 2：
     * //
     * //
     * //输入：s = "PAYPALISHIRING", numRows = 4
     * //输出："PINALSIGYAHRPI"
     * //解释：
     * //P     I    N
     * //A   L S  I G
     * //Y A   H R
     * //P     I
     * //
     * //
     * // 示例 3：
     * //
     * //
     * //输入：s = "A", numRows = 1
     * //输出："A"
     * //
     * //
     * //
     * //
     * // 提示：
     * //
     * //
     * // 1 <= s.length <= 1000
     * // s 由英文字母（小写和大写）、',' 和 '.' 组成
     * // 1 <= numRows <= 1000
     */
    void zigzagTransformation();

    /**
     * //给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
     * //
     * // 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。
     * //假设环境不允许存储 64 位整数（有符号或无符号）。
     * //
     * //
     * //
     * // 示例 1：
     * //
     * //
     * //输入：x = 123
     * //输出：321
     * //
     * //
     * // 示例 2：
     * //
     * //
     * //输入：x = -123
     * //输出：-321
     * //
     * //
     * // 示例 3：
     * //
     * //
     * //输入：x = 120
     * //输出：21
     * //
     * //
     * // 示例 4：
     * //
     * //
     * //输入：x = 0
     * //输出：0
     * //
     * //
     * //
     * //
     * // 提示：
     * //
     * //
     * // -231 <= x <= 231 - 1
     */
    void integerInversion();

    /**
     * //请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。
     * //
     * // 函数 myAtoi(string s) 的算法如下：
     * //
     * //
     * // 读入字符串并丢弃无用的前导空格
     * // 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
     * // 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
     * // 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤
     * //2 开始）。
     * // 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固
     * //定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
     * // 返回整数作为最终结果。
     * //
     * //
     * // 注意：
     * //
     * //
     * // 本题中的空白字符只包括空格字符 ' ' 。
     * // 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。
     * //
     * //
     * //
     * //
     * // 示例 1：
     * //
     * //
     * //输入：s = "42"
     * //输出：42
     * //解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
     * //第 1 步："42"（当前没有读入字符，因为没有前导空格）
     * //         ^
     * //第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
     * //         ^
     * //第 3 步："42"（读入 "42"）
     * //           ^
     * //解析得到整数 42 。
     * //由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。
     * //
     * // 示例 2：
     * //
     * //
     * //输入：s = "   -42"
     * //输出：-42
     * //解释：
     * //第 1 步："   -42"（读入前导空格，但忽视掉）
     * //            ^
     * //第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
     * //             ^
     * //第 3 步："   -42"（读入 "42"）
     * //               ^
     * //解析得到整数 -42 。
     * //由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。
     * //
     * //
     * // 示例 3：
     * //
     * //
     * //输入：s = "4193 with words"
     * //输出：4193
     * //解释：
     * //第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）
     * //         ^
     * //第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
     * //         ^
     * //第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）
     * //             ^
     * //解析得到整数 4193 。
     * //由于 "4193" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。
     * //
     * //
     * //
     * //
     * // 提示：
     * //
     * //
     * // 0 <= s.length <= 200
     * // s 由英文字母（大写和小写）、数字（0-9）、' '、'+'、'-' 和 '.' 组成
     */
    void convertStringNumber();

    /**
     * //给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。
     * //
     * // 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
     * //
     * //
     * // 例如，121 是回文，而 123 不是。
     * //
     * //
     * //
     * //
     * // 示例 1：
     * //
     * //
     * //输入：x = 121
     * //输出：true
     * //
     * //
     * // 示例 2：
     * //
     * //
     * //输入：x = -121
     * //输出：false
     * //解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
     * //
     * //
     * // 示例 3：
     * //
     * //
     * //输入：x = 10
     * //输出：false
     * //解释：从右向左读, 为 01 。因此它不是一个回文数。
     * //
     * //
     * //
     * //
     * // 提示：
     * //
     * //
     * // -231 <= x <= 231 - 1
     */
    void palindromeNumber();

    /**
     * //给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
     * //
     * //
     * // '.' 匹配任意单个字符
     * // '*' 匹配零个或多个前面的那一个元素
     * //
     * //
     * // 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
     * //
     * //
     * // 示例 1：
     * //
     * //
     * //输入：s = "aa", p = "a"
     * //输出：false
     * //解释："a" 无法匹配 "aa" 整个字符串。
     * //
     * //
     * // 示例 2:
     * //
     * //
     * //输入：s = "aa", p = "a*"
     * //输出：true
     * //解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
     * //
     * //
     * // 示例 3：
     * //
     * //
     * //输入：s = "ab", p = ".*"
     * //输出：true
     * //解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
     * //
     * //
     * //
     * //
     * // 提示：
     * //
     * //
     * // 1 <= s.length <= 20
     * // 1 <= p.length <= 30
     * // s 只包含从 a-z 的小写字母。
     * // p 只包含从 a-z 的小写字母，以及字符 . 和 *。
     * // 保证每次出现字符 * 时，前面都匹配到有效的字符
     */
    void regularExpressionMatching();

    /**
     * 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
     *
     * 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
     *
     * 返回容器可以储存的最大水量。
     *
     * 说明：你不能倾斜容器。
     *
     * 来源：力扣（LeetCode）
     * 链接：https://leetcode.cn/problems/container-with-most-water
     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
     */
    void holdMostWater();
}
